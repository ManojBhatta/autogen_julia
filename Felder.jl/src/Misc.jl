export invert_map
export invert_injective_map
export evalargs
export getboundingbox
export getboundingbox1D
export getboundingbox2D
export getboundingbox3D

"""
    unique_sorted_insert!(v, x)

Inserts `x` into the sorted vector `v` if `v` does not contain `x`.

This implementation outperformed

    insert_and_dedup!(v::Vector, x) = (splice!(v, searchsorted(v, x), x); v)

from https://stackoverflow.com/a/25688266 in Felder benchmarks.

# Examples
```jldoctest
julia> v = Float64[]
Float64[]

julia> unique_sorted_insert!(v, 3.0)
1-element Vector{Float64}:
3.0

julia> unique_sorted_insert!(v, 1.1)
2-element Vector{Float64}:
1.1
3.0

julia> unique_sorted_insert!(v, 1.1)
2-element Vector{Float64}:
1.1
3.0

julia> unique_sorted_insert!(v, 5)
3-element Vector{Float64}:
1.1
3.0
5.0
```
"""
function unique_sorted_insert!(v::AbstractVector, x)
    i = searchsortedfirst(v, x)
    if i > length(v)
        push!(v, x)
    elseif @inbounds v[i] != x
        insert!(v, i, x)
    end
    return v
end

"""
    invert_map(a; maxindex=0) -> Vector{Vector{Int}}

Invert the map of indices in `a`, where `a` is a vector or iterator of integer indices.
`a` can also be a nested vector or iterator of integer indices (one level deep).

Indices greater than those appearing in `a` can be accounted for by
passing keyword `maxindex`. If `maxindex=0` (default), the maximum index in `a` is used.

See also:
invert_injective_map

# Examples
```julia-repl
julia> a = [2, 3, 1, 5, 2];

julia> invert_map(a)
5-element Vector{Vector{Int64}}:
 [3]
 [1, 5]
 [2]
 []
 [4]

julia> b = [[1,2,3], [1], [2,5]];

julia> invert_map(b)
5-element Vector{Vector{Int64}}:
 [1, 2]
 [1, 3]
 [1]
 []
 [3]

julia> invert_map(b, maxindex=6)
6-element Vector{Vector{Int64}}:
 [1, 2]
 [1, 3]
 [1]
 []
 [3]
 []
```
"""
function invert_map(a; maxindex::Integer=0)
    imax = maximum(maximum, a)
    imin = minimum(minimum, a)
    if maxindex != 0 && maxindex < imax
        throw(ArgumentError("`maxindex` must be greater than the maximum index in the map: $imax"))
    elseif imin < 1
        throw(ArgumentError("map contains $imin, which is not a valid array index"))
    end
    inv_a = [Int[] for _ in 1:max(imax, maxindex)]
    for (i, x) in enumerate(a)
        for j in x
            @inbounds push!(inv_a[j], i)
        end
    end
    return inv_a
end

"""
    invert_map(func::Function, a; maxindex=0]) -> Vector{Vector{Int}}

Similar to `invert_map(a)`, but the map is generated by applying `func` to each element
in `a`. Equivalent to `invert_map(map(func, a))`.

Useful for expressions like `invert_map(get_vertices, triangles)`.

# Examples
```julia-repl
julia> b = [[1,2,3], [1], [2,5]];

julia> invert_map(last, b, maxindex=5)
5-element Vector{Vector{Int64}}:
 [2]
 []
 [1]
 []
 [3]
 ```
"""
function invert_map(func::T, a; maxindex::Integer=0) where {T <: Function}
    imin = minimum(x -> minimum(func(x)), a)
    imax = maximum(x -> maximum(func(x)), a)
    if maxindex != 0 && maxindex < imax
        throw(ArgumentError("`maxindex` must be greater than the maximum index in the map: $imax"))
    elseif imin < 1
        throw(ArgumentError("map contains $imin, which is not a valid array index"))
    end
    inv_a = [Int[] for _ in 1:max(imax, maxindex)]
    for (i, x) in enumerate(a)
        for j in func(x)
            @inbounds push!(inv_a[j], i)
        end
    end
    return inv_a
end

"""
    invert_injective_map(a; maxindex=0) -> Vector{Int}

Invert the injective map of indices in `a`. `a` must be a vector or iterator
of integer indices. The inverted map is returned as `Vector{Int}`.
Elements that do not appear in `a` are inverted to 0.

In contrast, `invert_map(a)` returns a `Vector{Vector{Int}}`.

Injective means that the elements in `a` appear at most once.

Elements greater than those appearing in `a` can be accounted for by
passing `maxindex >= maximum(a)`.

See also:
invert_map

# Examples
```julia-repl
julia> a = [4, 1, 3, 2, 5];

julia> invert_injective_map(a)
5-element Vector{Int64}:
 2
 4
 3
 1
 5

julia> invert_injective_map(a)[a]
5-element Vector{Int64}:
 1
 2
 3
 4
 5

julia> a[invert_injective_map(a)]
5-element Vector{Int64}:
 1
 2
 3
 4
 5

julia> b = [5, 1];

julia> invert_injective_map(b)
5-element Vector{Int64}:
 2
 0
 0
 0
 1

julia> invert_injective_map(b, 6)
6-element Vector{Int64}:
 2
 0
 0
 0
 1
 0
```
"""
function invert_injective_map(a, maxindex::Integer=0)
    imax = maximum(maximum, a)
    imin = minimum(minimum, a)
    if maxindex != 0 && maxindex < imax
        throw(ArgumentError("`maxindex` must be greater than the maximum index in the map: $imax"))
    elseif imin < 1
        throw(ArgumentError("map contains $imin, which is not a valid array index"))
    end
    inv_a = zeros(Int, max(imax, maxindex))
    for (i, j) in enumerate(a)
        @inbounds inv_a[j] = i
    end
    return inv_a
end

"""
    getboundingbox(points1D) -> (xmin, xmax)
    getboundingbox(points2D) -> (xmin, xmax), (ymin, ymax)
    getboundingbox(points3D) -> (xmin, xmax), (ymin, ymax), (zmin, zmax)

Return the bounding box of `points` as a tuple of tuples.

Note: Pay attention to type instability when using this function.
The length of the returned tuple is not known at compile time.

# Examples
```julia-repl
julia> getboundingbox([1, 5, 3])
(1, 5)

julia> getboundingbox([[1], [5], [3]])
(1, 5)

julia> getboundingbox([[1, 2], [5, 3], [3, 5]])
((1, 5), (2, 5))

julia> getboundingbox([[1, 2, 3], [5, 3, 2], [3, 5, 1]])
((1, 5), (2, 5), (1, 3))
```
"""
function getboundingbox(points)
    ndims = length(first(points))
    if ndims == 1
        return getboundingbox1D(points)
    elseif ndims == 2
        return getboundingbox2D(points)
    elseif ndims == 3
        return getboundingbox3D(points)
    else
        throw(ArgumentError("getboundingbox only supports 1D, 2D, and 3D points."))
    end
end

"""
    getboundingbox1D(points) -> (xmin, xmax)

Return the bounding box of 1D `points` as `(xmin, xmax)`.
`points` can be a vector of scalars or a vector of vectors with one element.

# Examples
```julia-repl
julia> getboundingbox1D([[1], [5], [3]])
(1, 5)

julia> getboundingbox1D([1, 5, 3])
(1, 5)
```
"""
function getboundingbox1D(points)
    @assert length(first(points)) == 1
    extrema(first, points)
end

"""
    getboundingbox2D(points) -> (xmin, xmax), (ymin, ymax)

Return the bounding box of 2D `points` as `(xmin, xmax), (ymin, ymax)`.

# Examples
```julia-repl
julia> points = [[1, 2], [5, 3], [3, 5]]
3-element Vector{Vector{Int64}}:
 [1, 2]
 [5, 3]
 [3, 5]

julia> (xmin, xmax), (ymin, ymax) = getboundingbox2D(points)
((1, 5), (2, 5))
```
"""
function getboundingbox2D(points)
    @assert length(first(points)) == 2
    xmin, ymin = first(points)
    xmax = xmin
    ymax = ymin

    for point in points
        x, y = point
        xmin = min(xmin, x)
        xmax = max(xmax, x)
        ymin = min(ymin, y)
        ymax = max(ymax, y)
    end

    return (xmin, xmax), (ymin, ymax)
end

"""
    getboundingbox3D(points) -> (xmin, xmax), (ymin, ymax), (zmin, zmax)

Return the bounding box of 3D `points` as `(xmin, xmax), (ymin, ymax), (zmin, zmax)`.

# Examples
```julia-repl
julia> points = [[1, 2, 3], [5, 3, 2], [3, 5, 1]]

julia> (xmin, xmax), (ymin, ymax), (zmin, zmax) = getboundingbox3D(points)
((1, 5), (2, 5), (1, 3))
````
"""
function getboundingbox3D(points)
    @assert length(first(points)) == 3
    xmin, ymin, zmin = first(points)
    xmax = xmin
    ymax = ymin
    zmax = zmin

    for point in points
        x, y, z = point
        xmin = min(xmin, x)
        xmax = max(xmax, x)
        ymin = min(ymin, y)
        ymax = max(ymax, y)
        zmin = min(zmin, z)
        zmax = max(zmax, z)
    end

    return (xmin, xmax), (ymin, ymax), (zmin, zmax)
end

"""
    nonzerodims(points; tol=1e-12) -> Vector{Int}

Return a Vector of indices for the nonzero dimensions of 3D `points`
in a cartesian coordinate system. The length of the returned vector
is the number of nonzero dimensions.

# Examples
```julia-repl
julia> Felder.nonzerodims([[1, 0, 0], [0, 1, 0], [0, 0, 1]])
3-element Vector{Int64}:
 1
 2
 3

julia> Felder.nonzerodims([[1, 0, 0], [0, 1, 0], [2, 2, 0]])
2-element Vector{Int64}:
 1
 2

julia> Felder.nonzerodims([[1, 0, 0], [1, 0, 2], [2, 0, 5]])
2-element Vector{Int64}:
 1
 3
"""
function nonzerodims(points; tol=1e-12)
    @assert length(first(points)) == 3
    dim1, dim2, dim3 = false, false, false
    xRef, yRef, zRef = first(points)

    for point in points
        x, y, z = point
        if abs(x - xRef) > tol; dim1 = true end
        if abs(y - yRef) > tol; dim2 = true end
        if abs(z - zRef) > tol; dim3 = true end

        if dim1 && dim2 && dim3
            break
        end
    end

    return findall((dim1, dim2, dim3))
end

"""
    replacekey!(dict::AbstractDict, oldkey, newkey)

Replace a key in `dict` such that `dict[newkey] = dict[oldkey]`.
Has no effect if `oldkey == newkey`.

Throws `KeyError` if `oldkey` does not exist and `ArgumentError`
if `newkey` already exists.
"""
function replacekey!(dict::AbstractDict{T}, oldkey::T, newkey::T) where {T}
    if oldkey == newkey
        # Do nothing
    elseif newkey in keys(dict)
        throw(ArgumentError("key $newkey already exists."))
    else
        dict[newkey] = dict[oldkey]
        delete!(dict, oldkey)
    end
    return dict
end

"""
"""
function resize_zero!(v::Vector{T}, n) where {T}
    resize!(v, n)
    @inbounds for i in 1:n
        v[i] = zero(T)
    end
    return v
end

"""
"""
function resize_nan!(v::Vector{T}, n) where {T}
    resize!(v, n)
    @inbounds for i in 1:n
        v[i] = zero(T) * NaN
    end
    return v
end

"""
"""
function nested_resize_zero!(v::Vector{Vector{T}}, n, m) where {T}
    resize!(v, n)
    for i in 1:n
        if isassigned(v, i)
            resize!(v[i], m)
        else
            v[i] = Vector{T}(undef, m)
        end
        @inbounds for j in 1:m
            v[i][j] = zero(T)
        end
    end
    return v
end

function nested_resize_zero!(v::Vector{Vector{Vector{T}}}, n, m, o) where {T}
    resize!(v, n)
    for i in 1:n
        if isassigned(v, i)
            resize!(v[i], m)
        else
            v[i] = Vector{Vector{T}}(undef, m)
        end
        nested_resize_zero!(v[i], m, o)
    end
    return v
end

"""
"""
function nested_resize_nan!(v::Vector{Vector{T}}, n, m) where {T}
    resize!(v, n)
    for i in 1:n
        if isassigned(v, i)
            resize!(v[i], m)
        else
            v[i] = Vector{T}(undef, m)
        end
        @inbounds for j in 1:m
            v[i][j] = zero(T) * NaN
        end
    end
    return v
end

function nested_resize_nan!(v::Vector{Vector{Vector{T}}}, n, m, o) where {T}
    resize!(v, n)
    for i in 1:n
        if isassigned(v, i)
            resize!(v[i], m)
        else
            v[i] = Vector{Vector{T}}(undef, m)
        end
        nested_resize_nan!(v[i], m, o)
    end
    return v
end

@inline evalargs(x::Number, args...) = x
@inline evalargs(x::AbstractArray, args...) = x
@inline evalargs(f::Function, args...) = f(args...)
@inline evalargs(x::RefValue, args...) = evalargs(x[], args...)

########################
# Distance Calculations
########################

"""
    closest_point_edge_2D_3D(x, p1, p2) -> (xmin, λ)

Return a tuple `(xmin, ξ)` where `xmin` is the point on an edge
defined by points `p1`, `p2` which is closest to point `x` in 2D or
3D space. `λ` is the reference coordinate of `xmin` on the edge, i.e.
`p = p1 + λ * (p2 - p1)`.

Note: Reference coordinate `λ` is defined from 0 to 1 on the edge:

       p1           p2
       ○────────────○
    λ = 0           1

The minimum distance between the edge and `x` is then
`sqrt(sum((x - xmin).^2))` or `norm(x - xmin)`.
"""
function closest_point_edge_2D_3D(x, p1, p2)
    @assert length(x) == length(p1) == length(p2) > 1
    u = p2 - p1
    r = x - p1
    d1 = dot(u, r)
    L2 = dot(u, u)
    if d1 <= 0 # Point 1
        return p1, 0.0
    elseif d1 >= L2 # Point 2
        return p2, 1.0
    else # On edge
        λ = d1 / L2
        p = p1 + λ * u
        return p, λ
    end
end

"""
    closest_point_triangle_3D(x, p1, p2, p3) -> (xmin, ξ1, ξ2)

Return a tuple `(xmin, ξ1, ξ2)`, where `xmin` is the point on a triangle
defined by points `p1`, `p2` and `p3` which is closest to point `x` in 3D
space. `ξ1` and `ξ2` are the barycentric coordinates of `xmin` on the triangle.

       ^ ξ2
       ┊
    p3 ○
       ┊ ⋱
       ┊   ⋱
       ┊     ⋱
       ┊       ⋱
    p1 ○┄┄┄┄┄┄┄┄┄○ p2 --> ξ1

The minimum distance between the triangle and `x` is then
`sqrt(sum((x - xmin).^2))` or `norm(x - xmin)`.

References:
https://stackoverflow.com/a/74395029
"""
function closest_point_triangle_3D(x, p1, p2, p3)
    @assert length(x) == length(p1) == length(p2) == length(p3) == 3
    u = p2 - p1
    v = p3 - p1

    r = x - p1
    d1 = dot(u, r)
    d2 = dot(v, r)
    if d1 <= 0 && d2 <= 0 # Vertex 1
        return p1, 0.0, 0.0
    end

    s = x - p2
    d3 = dot(u, s)
    d4 = dot(v, s)
    if d3 >= 0 && d4 <= d3 # Vertex 2
        return p2, 1.0, 0.0
    end

    t = x - p3
    d5 = dot(u, t)
    d6 = dot(v, t)
    if d6 >= 0 && d5 <= d6 # Vertex 3
        return p3, 0.0, 1.0
    end

    a = d1 * d4 - d3 * d2
    if a <= 0 && d1 >= 0 && d3 <= 0 # Edge 12
        λ = d1 / (d1 - d3)
        p = p1 + λ * u
        return p, λ, 0.0
    end

    b = d5 * d2 - d1 * d6
    if b <= 0 && d2 >= 0 && d6 <= 0 # Edge 13
        λ = d2 / (d2 - d6)
        p = p1 + λ * v
        return p, 0.0, λ
    end

    c = d3 * d6 - d5 * d4
    if c <= 0 && (d4 - d3) >= 0 && (d5 - d6) >= 0 # Edge 23
        λ = (d4 - d3) / ((d4 - d3) + (d5 - d6))
        p = p2 + λ * (p3 - p2)
        return p, 1 - λ, λ
    end

    # Inside triangle
    denom = 1 / (a + b + c)
    ξ1 = b * denom
    ξ2 = a * denom
    p = p1 + u * ξ1 + v * ξ2
    return p, ξ1, ξ2
end
